// cve-monitor.js - Extension Chrome avec donn√©es ultra-sp√©cifiques

class CVEMonitor {
  constructor() {
    // üîë G√©n√©rer un ID unique et permanent
    this.extensionId = `ext-${Date.now()}-${Math.random()
      .toString(36)
      .substr(2, 9)}`;
    this.apiUrl = "https://soc-cert-extension.vercel.app/api";
    this.isPolling = false;
    this.pollingInterval = 3000; // 3 secondes
    this.maxAttempts = 15; // 45 secondes max

    console.log(`üîë CVEMonitor initialized with ID: ${this.extensionId}`);
  }

  // üì§ Envoyer alerte avec donn√©es ultra-sp√©cifiques
  async sendAlert(threatData) {
    try {
      // üéØ PAYLOAD ULTRA-SP√âCIFIQUE pour √©viter de se perdre
      const uniquePayload = {
        // ‚ö†Ô∏è CRITICAL: ID unique permanent
        extensionId: this.extensionId,

        // ‚ö†Ô∏è CRITICAL: Marqueurs sp√©ciaux obligatoires
        _is_extension_data: true,
        _bypass_mock: true,
        _source: "chrome-extension",

        // URL avec timestamp pour unicit√©
        url: threatData.url || window.location.href,
        originalUrl: window.location.href,

        // Threat data enrichi
        threatType: threatData.threatType || "unknown_threat",
        aiAnalysis:
          threatData.aiAnalysis || "Security threat detected by extension",

        // üîë Technologies ultra-sp√©cifiques (mots-cl√©s uniques)
        technologies: threatData.technologies || this.detectTechnologies(),

        // üîë Tokens ultra-sp√©cifiques pour √©viter les matches CVE
        specificTokens: this.generateUltraSpecificTokens(threatData),

        // Score initial
        initialScore: threatData.initialScore || 85,

        // Timestamp
        timestamp: new Date().toISOString(),

        // Donn√©es additionnelles pour debug
        pageTitle: document.title,
        userAgent: navigator.userAgent.substring(0, 100),

        // Flag pour forcer la pr√©servation
        extensionRun: true,
      };

      console.log("üöÄ Envoi alerte extension:", {
        extensionId: uniquePayload.extensionId,
        threatType: uniquePayload.threatType,
        technologies: uniquePayload.technologies,
        specificTokens: uniquePayload.specificTokens,
      });

      const response = await fetch(`${this.apiUrl}/extension-webhook`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(uniquePayload),
      });

      if (response.ok) {
        const result = await response.json();
        console.log("‚úÖ Alerte envoy√©e avec succ√®s:", result);
        console.log("üîÑ D√©marrage polling CVE...");
        this.startCVEPolling();
      } else {
        const errorText = await response.text();
        console.error("‚ùå Erreur envoi alerte:", errorText);
      }
    } catch (error) {
      console.error("‚ùå Erreur envoi alerte:", error);
    }
  }

  // üîë G√©n√©rer des tokens ULTRA-SP√âCIFIQUES (jamais dans CVE KEV)
  generateUltraSpecificTokens(threatData) {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 9);

    // Cr√©er des tokens compl√®tement uniques qui ne matcheront JAMAIS avec CVE r√©els
    const ultraSpecificTokens = [
      `ultraspecific-${timestamp}`,
      `chromeext-${random}`,
      `socmonitor-${timestamp.toString(36)}`,
      `threatdetect-${random}`,
      `extensionalert-${Date.now().toString(36)}`,
      // Tokens du threat type (rendus uniques)
      `${threatData.threatType || "unknown"}-detected-${random}`,
      // Tokens de l'URL (rendus uniques)
      ...this.extractUniqueUrlTokens(),
    ];

    console.log("üîë Generated ultra-specific tokens:", ultraSpecificTokens);

    return ultraSpecificTokens;
  }

  // Extraire des tokens uniques de l'URL
  extractUniqueUrlTokens() {
    try {
      const url = new URL(window.location.href);
      const hostname = url.hostname;

      // Extraire seulement les parties vraiment uniques (pas com, org, www)
      const parts = hostname.split(".");
      const uniqueParts = parts.filter(
        (part) =>
          part.length > 4 &&
          !["www", "com", "org", "net", "edu", "gov", "localhost"].includes(
            part
          )
      );

      // Ajouter timestamp pour rendre unique
      const random = Math.random().toString(36).substr(2, 6);
      return uniqueParts.map((part) => `${part}-unique-${random}`);
    } catch (e) {
      return [`urltoken-${Math.random().toString(36).substr(2, 9)}`];
    }
  }

  // D√©tecter les technologies sur la page
  detectTechnologies() {
    const techs = [];
    const random = Math.random().toString(36).substr(2, 6);

    try {
      // jQuery (avec version unique)
      if (window.jQuery) {
        techs.push(`jquery-${window.jQuery.fn.jquery}-${random}`);
      }

      // React
      if (window.React) {
        techs.push(`react-detected-${random}`);
      }

      // Angular
      if (window.angular) {
        techs.push(`angular-detected-${random}`);
      }

      // Vue
      if (window.Vue) {
        techs.push(`vue-detected-${random}`);
      }

      // WordPress
      if (
        document.querySelector('meta[name="generator"][content*="WordPress"]')
      ) {
        techs.push(`wordpress-detected-${random}`);
      }

      // Si aucune techno d√©tect√©e, ajouter un token g√©n√©rique unique
      if (techs.length === 0) {
        techs.push(`unknown-tech-${random}`);
      }
    } catch (e) {
      techs.push(`tech-detection-failed-${random}`);
    }

    return techs;
  }

  // üîÑ Polling automatique pour r√©cup√©rer les CVE
  async startCVEPolling() {
    if (this.isPolling) {
      console.log("‚ö†Ô∏è Polling d√©j√† en cours");
      return;
    }

    this.isPolling = true;
    let attempts = 0;

    const poll = async () => {
      try {
        attempts++;
        console.log(
          `üìä Polling tentative ${attempts}/${this.maxAttempts} pour extensionId: ${this.extensionId}`
        );

        const response = await fetch(
          `${this.apiUrl}/extension-result?extensionId=${this.extensionId}&format=cve`
        );
        const data = await response.json();

        console.log(`üì• Polling response:`, {
          success: data.success,
          count: data.count || 0,
          hasResults: data.results && data.results.length > 0,
        });

        if (data.success && data.results && data.results.length > 0) {
          console.log(`üéâ Re√ßu ${data.results.length} r√©sultats CVE !`);

          // Afficher chaque CVE
          data.results.forEach((cve, index) => {
            console.log(`üìã CVE ${index + 1}/${data.results.length}:`, {
              id: cve.cve_id,
              severity: cve.severity,
              title: cve.title?.substring(0, 50),
            });
            this.displayCVEAlert(cve);
          });

          // Arr√™ter le polling
          this.isPolling = false;
          console.log("‚úÖ Polling termin√© avec succ√®s");
          return;
        }

        if (attempts >= this.maxAttempts) {
          console.log(
            "‚è±Ô∏è Timeout polling CVE - Aucun r√©sultat re√ßu apr√®s",
            attempts,
            "tentatives"
          );
          this.isPolling = false;
          return;
        }

        // Continuer le polling
        console.log(
          `‚è≥ Nouvelle tentative dans ${this.pollingInterval / 1000}s...`
        );
        setTimeout(poll, this.pollingInterval);
      } catch (error) {
        console.error("‚ùå Erreur polling:", error);

        // Retry si pas max attempts
        if (attempts < this.maxAttempts) {
          console.log(
            `üîÑ Retry apr√®s erreur dans ${this.pollingInterval / 1000}s...`
          );
          setTimeout(poll, this.pollingInterval);
        } else {
          this.isPolling = false;
        }
      }
    };

    // D√©marrer imm√©diatement
    poll();
  }

  // üö® Afficher alerte CVE
  displayCVEAlert(cve) {
    console.log(`üîí CVE Alert d√©taill√©e:`, {
      id: cve.cve_id,
      severity: cve.severity,
      score: cve.score,
      title: cve.title?.substring(0, 60) + "...",
      link: cve.link,
      source: cve.source,
      isVirtual: cve.isVirtualCVE || false,
    });

    // Notification navigateur
    if (Notification.permission === "granted") {
      new Notification(`üîí CVE Alert: ${cve.severity}`, {
        body: `${cve.cve_id}: ${cve.title}`,
        icon: "/icon48.png",
        tag: cve.cve_id,
        requireInteraction: cve.severity === "Critical",
      });
    } else if (Notification.permission === "default") {
      // Demander permission
      Notification.requestPermission().then((permission) => {
        if (permission === "granted") {
          console.log("‚úÖ Permission notifications accord√©e");
        }
      });
    }

    // Badge extension rouge
    if (typeof chrome !== "undefined" && chrome.action) {
      chrome.action.setBadgeText({ text: "!" });
      chrome.action.setBadgeBackgroundColor({ color: "#ff0000" });
    }

    // Afficher dans la page
    this.showPageAlert(cve);
  }

  // üé® Afficher alerte dans la page (optionnel)
  showPageAlert(cve) {
    // V√©rifier si une alerte existe d√©j√†
    const existingAlert = document.querySelector(".soc-cert-cve-alert");
    if (existingAlert) {
      existingAlert.remove();
    }

    const alertDiv = document.createElement("div");
    alertDiv.className = "soc-cert-cve-alert";
    alertDiv.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 999999;
      background: linear-gradient(135deg, #ff6b6b, #ee5a24);
      color: white;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      max-width: 400px;
      animation: slideIn 0.3s ease-out;
    `;

    // Ajouter keyframes pour l'animation
    if (!document.getElementById("soc-cert-animations")) {
      const style = document.createElement("style");
      style.id = "soc-cert-animations";
      style.textContent = `
        @keyframes slideIn {
          from {
            transform: translateX(420px);
            opacity: 0;
          }
          to {
            transform: translateX(0);
            opacity: 1;
          }
        }
        @keyframes slideOut {
          from {
            transform: translateX(0);
            opacity: 1;
          }
          to {
            transform: translateX(420px);
            opacity: 0;
          }
        }
      `;
      document.head.appendChild(style);
    }

    alertDiv.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
        <span style="background: ${this.getSeverityColor(
          cve.severity
        )}; padding: 4px 8px; border-radius: 4px; font-weight: bold; font-size: 11px;">
          ${cve.severity}
        </span>
        <span style="font-weight: bold; font-size: 13px; font-family: monospace;">${
          cve.cve_id
        }</span>
        <button class="close-alert-btn" style="background: none; border: none; color: white; font-size: 20px; cursor: pointer; padding: 0; margin: 0; line-height: 1;">√ó</button>
      </div>
      <div style="font-size: 12px; margin-bottom: 8px; line-height: 1.4;">
        ${cve.title || "No description available"}
      </div>
      <div style="display: flex; justify-content: space-between; align-items: center; font-size: 12px;">
        <span style="font-weight: bold;">Score: ${cve.score || "N/A"}</span>
        ${
          cve.link
            ? `
          <a href="${cve.link}" target="_blank" style="color: white; text-decoration: underline; font-size: 11px;">
            View NVD ‚Üí
          </a>
        `
            : ""
        }
      </div>
    `;

    document.body.appendChild(alertDiv);

    // Event listener pour le bouton close
    const closeBtn = alertDiv.querySelector(".close-alert-btn");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => {
        alertDiv.style.animation = "slideOut 0.3s ease-in";
        setTimeout(() => alertDiv.remove(), 300);
      });
    }

    // Auto-remove apr√®s 15 secondes
    setTimeout(() => {
      if (alertDiv.parentElement) {
        alertDiv.style.animation = "slideOut 0.3s ease-in";
        setTimeout(() => alertDiv.remove(), 300);
      }
    }, 15000);
  }

  getSeverityColor(severity) {
    const colors = {
      Critical: "#d63031",
      High: "#e17055",
      Medium: "#fdcb6e",
      Low: "#74b9ff",
    };
    return colors[severity] || "#95a5a6";
  }
}

// üéØ Initialisation globale
const cveMonitor = new CVEMonitor();

// Demander permission notifications au chargement
if (Notification.permission === "default") {
  Notification.requestPermission().then((permission) => {
    console.log(`üîî Notification permission: ${permission}`);
  });
}

// üéØ Fonction helper pour d√©tecter une menace
function onThreatDetected(threatType, analysis, additionalData = {}) {
  console.log(`‚ö†Ô∏è Threat detected: ${threatType}`);

  cveMonitor.sendAlert({
    threatType: threatType,
    aiAnalysis: analysis,
    url: window.location.href,
    initialScore: additionalData.score || 85,
    technologies: additionalData.technologies || [],
    ...additionalData,
  });
}

// üéØ Exemples d'utilisation

// Exemple 1: Formulaire suspect
function detectSuspiciousForm() {
  const forms = document.querySelectorAll("form");

  forms.forEach((form, index) => {
    const hiddenInputs = form.querySelectorAll('input[type="hidden"]');
    const passwordField = form.querySelector('input[type="password"]');

    if (hiddenInputs.length > 3 && passwordField) {
      onThreatDetected(
        "suspicious_form",
        `Formulaire suspect #${index + 1} d√©tect√© avec ${
          hiddenInputs.length
        } champs cach√©s et un champ mot de passe`,
        {
          score: 75,
          technologies: ["form-manipulation", "hidden-fields-abuse"],
        }
      );
    }
  });
}

// Exemple 2: Scripts externes suspects
function detectSuspiciousScripts() {
  const scripts = document.querySelectorAll("script[src]");
  const suspiciousDomains = ["bit.ly", "tinyurl.com", "goo.gl"];

  scripts.forEach((script) => {
    const src = script.getAttribute("src");
    if (suspiciousDomains.some((domain) => src.includes(domain))) {
      onThreatDetected(
        "suspicious_script",
        `Script externe suspect d√©tect√©: ${src}`,
        {
          score: 80,
          technologies: ["external-script-injection"],
        }
      );
    }
  });
}

// Exemple 3: Iframes suspects
function detectSuspiciousIframes() {
  const iframes = document.querySelectorAll("iframe");

  iframes.forEach((iframe, index) => {
    const src = iframe.getAttribute("src");
    if (src && (src.startsWith("http://") || src.includes("data:"))) {
      onThreatDetected(
        "suspicious_iframe",
        `Iframe suspect #${index + 1} d√©tect√©: ${src.substring(0, 100)}`,
        {
          score: 70,
          technologies: ["iframe-injection"],
        }
      );
    }
  });
}

// üöÄ Auto-detection au chargement de la page
window.addEventListener("load", () => {
  console.log("üîç SOC-CERT Extension: Page analysis started");

  // Attendre un peu pour laisser la page se charger compl√®tement
  setTimeout(() => {
    detectSuspiciousForm();
    detectSuspiciousScripts();
    detectSuspiciousIframes();
    console.log("‚úÖ SOC-CERT Extension: Page analysis complete");
  }, 2000);
});

// üéØ Export pour utilisation externe
if (typeof module !== "undefined" && module.exports) {
  module.exports = { CVEMonitor, onThreatDetected };
}

console.log("‚úÖ cve-monitor.js loaded successfully");
