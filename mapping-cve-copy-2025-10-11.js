// COPY of mapping-cve.js created 2025-10-11
// Purpose: provide a visible duplicate so user can open and inspect without touching original

// ============================================================================
// MAPPING CVE - CODE FINAL COMPLET (n8n Code node)
// ============================================================================
// Settings n8n:
//   - Run Once for All Items = ON
// ============================================================================

console.log("=== üîç MAPPING CVE DEBUG COMPLET ===");

const items = $input.all();
console.log("üì• RAW INPUT ITEMS:", items.length);
items.forEach((item, idx) => {
  console.log(`üì• Item ${idx}:`, JSON.stringify(item.json, null, 2));
});

// ‚úÖ GESTION DES DEUX FORMATS POSSIBLES
let extensionItems = [];

// Format 1: Items directs (chaque extension est un item s√©par√©)
const directExtensions = items.filter(
  (i) => i.json?.extensionId && !i.json?.extensions
);

// Format 2: R√©ponse API compl√®te avec extensions[]
const apiResponses = items.filter(
  (i) => i.json?.extensions && Array.isArray(i.json.extensions)
);

console.log(`üìä Direct extensions: ${directExtensions.length}`);
console.log(`üìä API responses: ${apiResponses.length}`);

if (directExtensions.length > 0) {
  // Format direct
  extensionItems = directExtensions;
  console.log("‚úÖ Using direct extension format");
} else if (apiResponses.length > 0) {
  // Format API - extraire les extensions du tableau
  extensionItems = [];
  apiResponses.forEach((response) => {
    if (response.json.extensions && response.json.extensions.length > 0) {
      response.json.extensions.forEach((ext) => {
        extensionItems.push({ json: ext });
      });
    }
  });
  console.log(
    `‚úÖ Extracted ${extensionItems.length} extensions from API responses`
  );
} else {
  console.log("‚ùå No valid extension data found in input");
  extensionItems = [];
}

const ext = extensionItems;
const pool = items.filter(
  (i) =>
    !i.json?.extensionId && !i.json?._is_extension_data && !i.json?.extensions
);

console.log(
  `üîç MAPPING CVE: ${ext.length} extensions, ${pool.length} autres, ${items.length} total`
);

// ============================================================================
// √âTAPE 1 : CONSTRUIRE BANQUE CVE CANDIDATS (KEV, NIST, TEXT)
// ============================================================================

const cands = [];
const add = (x) => {
  if (x?.id && !cands.some((y) => y.id === x.id)) cands.push(x);
};

console.log(
  `üì• Analyse des ${items.length} items pour extraire les CVE candidats...`
);

for (const it of items) {
  const j = it.json || {};

  // KEV (tableau vulnerabilities)
  if (Array.isArray(j.vulnerabilities)) {
    console.log(`  KEV trouv√© avec ${j.vulnerabilities.length} vuln√©rabilit√©s`);
    for (const v of j.vulnerabilities || []) {
      if (v.cveID) {
        add({
          id: v.cveID,
          title: v.vulnerabilityName || `CVE ${v.cveID}`,
          src: "KEV",
          sev: v.severity || "High",
          score: v.baseScore || 70,
          pub: v.dateAdded,
          description: v.shortDescription || "",
          requiredAction: v.requiredAction || "",
          notes: v.notes || "",
          product: v.product || "",
          vendor: v.vendorProject || "",
          raw: v,
        });
      }
    }
  }

  // NIST (structure cve.id)
  if (j.cve?.id) {
    console.log(`  NIST CVE trouv√©: ${j.cve.id}`);
    const m =
      j.cve.metrics?.cvssMetricV31?.[0] || j.cve.metrics?.cvssMetricV30?.[0];
    add({
      id: j.cve.id,
      title:
        j.cve.descriptions?.[0]?.value ||
        j.cve.title?.[0]?.value ||
        `CVE ${j.cve.id}`,
      src: "NVD",
      sev: m?.cvssData?.baseSeverity || "MEDIUM",
      score: Math.round((m?.cvssData?.baseScore || 5) * 10),
      pub: j.cve.published,
      raw: j,
    });
  }

  // Text extract (CVE mentionn√© dans le texte)
  const re = /CVE[-_]\d{4}[-_]\d+/gi;
  const s = JSON.stringify(j);
  const textMatches = s.match(re) || [];
  if (textMatches.length > 0) {
    console.log(`  Text extract: ${textMatches.length} CVE trouv√©s`);
    new Set(textMatches.map((x) => x.replace("_", "-").toUpperCase())).forEach(
      (id) =>
        add({
          id,
          title: `CVE ${id}`,
          src: "TextExtract",
          sev: "Medium",
          score: 50,
          pub: new Date().toISOString(),
          raw: j,
        })
    );
  }
}

console.log(`üìã CVE candidats collect√©s: ${cands.length}`);
console.log(`üìã Top 10 candidats:`);
cands.slice(0, 10).forEach((c, i) => {
  console.log(`  ${i + 1}. ${c.id} (${c.src}): ${c.title.substring(0, 50)}...`);
});

// ============================================================================
// √âTAPE 2 : FONCTION HASH URL (pour CVE virtuel stable)
// ============================================================================

function hashURL(url) {
  if (!url) return "000000";

  // Normaliser l'URL (enlever protocole, slash final, query string)
  const normalized = url
    .toLowerCase()
    .replace(/^https?:\/\//, "")
    .replace(/\/$/, "")
    .replace(/[?#].*$/, "");

  console.log(`  üîç URL normalis√©e: "${normalized}"`);

  // Simple hash bas√© sur charCodes
  let hash = 0;
  for (let i = 0; i < normalized.length; i++) {
    const char = normalized.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash; // Convertir en 32bit integer
  }

  // Retourner 6 chiffres positifs
  const sixDigits = Math.abs(hash).toString().slice(0, 6).padStart(6, "0");
  return sixDigits;
}

// ============================================================================
// √âTAPE 3 : NORMALISATION DES TOKENS (pour stabilit√©)
// ============================================================================

const tokenSynonyms = {
  malicious: [
    "suspicious",
    "malware",
    "harmful",
    "dangerous",
    "threat",
    "malevolent",
  ],
  unwanted: ["unwanted", "undesirable"],
  exploit: ["attack", "vulnerability", "weakness", "flaw"],
  remote: ["remote", "rce"],
  execution: ["execution", "exec", "running"],
  code: ["code", "script", "payload"],
  authentication: ["auth", "login", "credential", "password", "session"],
  privilege: ["privilege", "escalation", "elevation", "priv"],
  injection: ["injection", "xss", "sql", "command"],
  browser: ["browser", "chrome", "firefox", "safari", "edge", "webkit"],
  phishing: ["phishing", "spoof", "impersonation", "fake"],
};

function normalizeToken(token) {
  const tokenLow = token.toLowerCase().trim();

  for (const [canonical, synonyms] of Object.entries(tokenSynonyms)) {
    if (tokenLow === canonical || synonyms.includes(tokenLow)) {
      return canonical;
    }
  }

  return tokenLow;
}

function normalizeTokens(tokens) {
  const normalized = new Set();

  for (const token of tokens) {
    const norm = normalizeToken(token);
    normalized.add(norm);
  }

  return Array.from(normalized);
}

// ============================================================================
// √âTAPE 4 : MOTS-CL√âS ET FILTRES
// ============================================================================

const cyberKeywords = [
  "bash",
  "shellshock",
  "apache",
  "nginx",
  "mysql",
  "postgresql",
  "windows",
  "linux",
  "kernel",
  "openssl",
  "java",
  "python",
  "jenkins",
  "cisco",
  "juniper",
  "fortinet",
  "sudo",
  "curl",
  "chrome",
  "firefox",
  "safari",
  "edge",
  "node",
  "docker",
  "kubernetes",
  "redis",
  "mongodb",
  "elasticsearch",
  "wordpress",
  "joomla",
  "drupal",
  "php",
  "ruby",
  "perl",
  "oracle",
  "samsung",
  "android",
  "ios",
  "microsoft",
  "adobe",
  "vmware",
  "citrix",
  "login",
  "authentication",
  "password",
  "credential",
  "auth",
  "session",
  "cookie",
  "token",
  "oauth",
  "sso",
  "mfa",
  "2fa",
  "phishing",
  "spoofing",
  "impersonation",
  "bruteforce",
  "malware",
  "ransomware",
  "trojan",
  "backdoor",
  "rootkit",
  "unwanted",
  "suspicious",
  "malicious",
  "virus",
  "worm",
  "exploit",
  "vulnerability",
  "injection",
  "xss",
  "csrf",
  "obfuscation",
  "redirect",
  "remote",
  "execution",
  "code",
  "privilege",
  "escalation",
  "elevation",
  "browser",
  "webkit",
];

const genericTokens = [
  "security",
  "platform",
  "system",
  "admin",
  "interface",
  "dashboard",
  "version",
  "custom",
  "proprietary",
  "framework",
  "bypass",
  "targeting",
  "unique",
  "with",
  "vuln",
  "rabilit",
  "detecte",
  "expose",
  "protection",
  "adequate",
  "2025",
  "2024",
  "2023",
  "application",
  "service",
  "server",
  "client",
  "network",
  "web",
  "uses",
  "used",
  "using",
  "based",
  "allows",
  "could",
  "would",
  "might",
  "potential",
  "possible",
  "impact",
  "risk",
  "threat",
  "attack",
  "attacker",
  "user",
  "domain",
  "file",
  "data",
];

// ============================================================================
// FONCTIONS UTILITAIRES
// ============================================================================

function toks(u) {
  try {
    const h = new URL(u).hostname.replace(/^www\./, "");
    return h.split(".").slice(0, -1).filter(Boolean);
  } catch {
    return [];
  }
}

function low(x) {
  return (x || "").toString().toLowerCase();
}

// ============================================================================
// √âTAPE 5 : CORR√âLATION EXTENSION ‚Üî CVE
// ============================================================================

const out = [];

console.log(`üéØ D√©but corr√©lation pour ${ext.length} extensions...`);

for (const e of ext) {
  const data = e.json;

  console.log(
    `\nüéØ === Traitement extension ${data.extensionId || "UNKNOWN"} ===`
  );

  // Sauvegarde extensionId original
  const originalExtensionId =
    data.extensionId || data.original_data?.extensionId || "mapped";
  console.log(`  üìå extensionId original: "${originalExtensionId}"`);

  // Extraction donn√©es
  const url = data.url || data.link || data.extensionData?.originalUrl || "";
  const title = low(data.title || "");
  const analysis = low(
    data.aiAnalysis || data.text || data.extensionData?.aiAnalysis || ""
  );
  const tech = (data.extensionData?.technologies || [])
    .map((t) => low(t.name))
    .filter(Boolean);

  // Extraction des champs AI de l'extension
  const indicators = data.indicators || [];
  const riskScore = data.riskScore || 0;
  const confidence = data.confidence || 0;

  console.log(`  üîç DEBUG EXTRACTION:`);
  console.log(
    `    data.indicators:`,
    data.indicators,
    `type:`,
    typeof data.indicators
  );
  console.log(
    `    data.riskScore:`,
    data.riskScore,
    `type:`,
    typeof data.riskScore
  );
  console.log(
    `    data.confidence:`,
    data.confidence,
    `type:`,
    typeof data.confidence
  );
  console.log(`    ‚Üí indicators:`, indicators, `length:`, indicators.length);
  console.log(`    ‚Üí riskScore:`, riskScore);
  console.log(`    ‚Üí confidence:`, confidence);

  console.log(`  URL: "${url}"`);
  console.log(`  Title: "${title.substring(0, 50)}..."`);
  console.log(`  Analysis: "${analysis.substring(0, 100)}..."`);
  console.log(`  Indicators: ${JSON.stringify(indicators)}`);
  console.log(`  Risk Score: ${riskScore}`);
  console.log(`  Confidence: ${confidence}`);

  // Extraction tokens
  const titleTokens = title.match(/\b\w{4,}\b/g) || [];
  const analysisTokens = analysis.match(/\b\w{4,}\b/g) || [];
  const urlTokens = toks(url);

  // D√©tecter mots-cl√©s cyber
  const detectedKeywords = cyberKeywords.filter(
    (keyword) =>
      title.includes(keyword) ||
      analysis.includes(keyword) ||
      url.toLowerCase().includes(keyword)
  );

  console.log(`  Mots-cl√©s cyber d√©tect√©s: [${detectedKeywords.join(", ")}]`);

  // Combiner tous les tokens
  const allTokens = [
    ...new Set([
      ...urlTokens,
      ...titleTokens,
      ...analysisTokens,
      ...detectedKeywords,
      ...tech,
    ]),
  ];

  // Filtrer g√©n√©riques
  const filteredTokens = allTokens.filter(
    (t) =>
      t.length >= 4 &&
      !genericTokens.includes(t.toLowerCase()) &&
      !/^\d+$/.test(t)
  );

  // Normalisation (SUSPICIOUS ‚Üí malicious, etc.)
  const specificTokens = normalizeTokens(filteredTokens);

  console.log(
    `  Tokens bruts (${filteredTokens.length}): [${filteredTokens
      .slice(0, 8)
      .join(", ")}]${filteredTokens.length > 8 ? "..." : ""}`
  );
  console.log(
    `  Tokens NORMALIS√âS (${specificTokens.length}): [${specificTokens
      .slice(0, 8)
      .join(", ")}]${specificTokens.length > 8 ? "..." : ""}`
  );

  // ============================================================================
  // PRIORIT√â 1 : CVE MENTIONN√â DIRECTEMENT
  // ============================================================================

  const mentionedCVE = analysis.match(/cve[-_]?\d{4}[-_]?\d+/i);
  if (mentionedCVE) {
    const cveId = mentionedCVE[0].replace(/[-_]/g, "-").toUpperCase();
    const directMatch = cands.find((c) => c.id === cveId);
    if (directMatch) {
      const enrichedExtension = {
        ...data,
        extensionId: originalExtensionId,
        cve_id: directMatch.id,
        cveid: directMatch.id,
        mappedCVE: true,
        mappingConfidence: 10,
        mappingSource: directMatch.src,
        mappingTitle: directMatch.title,
        matchMethod: "direct_mention",
        specificTokens,
        isVirtual: false,
        // ‚úÖ AJOUTER LES CHAMPS AI DE L'EXTENSION
        indicators: indicators,
        riskScore: riskScore,
        confidence: confidence,
        // Champs KEV enrichis
        cve_description: directMatch.description,
        cve_requiredAction: directMatch.requiredAction,
        cve_notes: `${directMatch.notes || ""}\n\nAI Detection - Indicators: ${
          indicators.length > 0 ? indicators.join(", ") : "None"
        }. Risk Score: ${riskScore}. Confidence: ${confidence}. Context: ${analysis.substring(
          0,
          200
        )}...`,
        cve_product: directMatch.product,
        cve_vendor: directMatch.vendor,
        _is_extension_data: true,
        original_data: {
          ...data.original_data,
          extensionId: originalExtensionId,
        },
      };
      out.push({
        json: enrichedExtension,
        pairedItem: { item: ext.indexOf(e) },
      });
      console.log(`  ‚úÖ CVE mentionn√© directement: ${directMatch.id}`);
      continue;
    }
  }

  // ============================================================================
  // PRIORIT√â 2 : CORR√âLATION TOKENS AVEC SCORING
  // ============================================================================

  const matches = [];
  if (specificTokens.length > 0) {
    console.log(`  üîç Test corr√©lation avec ${cands.length} candidats...`);

    for (const c of cands) {
      const titleLow = low(c.title);
      const rawLow = low(JSON.stringify(c.raw || {}));
      const matchingTokens = specificTokens.filter(
        (t) => titleLow.includes(t) || rawLow.includes(t)
      );

      if (matchingTokens.length > 0) {
        const kev = c.src === "KEV";
        // --- Conservative KEV match rule: require product/vendor evidence ---
        let kevProductMatch = false;
        if (kev) {
          const candProducts = [];
          if (c.product) {
            if (Array.isArray(c.product))
              candProducts.push(
                ...c.product.map((x) => ("" + x).toLowerCase())
              );
            else candProducts.push(("" + c.product).toLowerCase());
          }
          if (c.vendor) candProducts.push(("" + c.vendor).toLowerCase());
          const rawText = JSON.stringify(c.raw || {}).toLowerCase();
          const extTokenSet = new Set(
            specificTokens.map((t) => t.toLowerCase())
          );
          for (const p of candProducts) {
            p.split(/[^a-z0-9]+/)
              .filter(Boolean)
              .forEach((tok) => {
                if (extTokenSet.has(tok)) kevProductMatch = true;
              });
            if (kevProductMatch) break;
          }
          if (!kevProductMatch) {
            for (const t of extTokenSet) {
              if (rawText.includes(t)) {
                kevProductMatch = true;
                break;
              }
            }
          }
        }
        // small positive contribution only when product/vendor matches, otherwise 0
        const kevContribution = kev && kevProductMatch ? 3 : 0;
        // penalize KEV candidates that lack product/vendor evidence to avoid false positives
        const kevPenalty = kev && !kevProductMatch ? -12 : 0;
        const cveYearMatch = c.id.match(/CVE-(\d{4})-/);
        const year = cveYearMatch ? parseInt(cveYearMatch[1]) : 2000;
        const age = 2025 - year;

        const recentBonus = age <= 2 ? 3 : 0;
        const agePenalty = age > 5 ? -(age - 5) * 2 : 0;
        const tokenScore = matchingTokens.length;

        const criticalTokens = [
          "authentication",
          "credential",
          "password",
          "session",
          "token",
          "oauth",
          "sso",
        ];
        const criticalMatches = matchingTokens.filter((t) =>
          criticalTokens.includes(t)
        ).length;

        // Bonus par type de menace
        let typeBonus = 0;

        if (
          specificTokens.includes("malicious") ||
          specificTokens.includes("unwanted")
        ) {
          const isMalwareCVE =
            titleLow.includes("malware") ||
            titleLow.includes("execution") ||
            titleLow.includes("remote code") ||
            titleLow.includes("backdoor");
          if (isMalwareCVE) {
            typeBonus += 20;
            console.log(`    üéØ BONUS MALWARE +20 pour ${c.id}`);
          }
        }

        if (specificTokens.includes("phishing")) {
          const isPhishingCVE =
            titleLow.includes("phish") || titleLow.includes("spoof");
          if (isPhishingCVE) {
            typeBonus += 20;
            console.log(`    üéØ BONUS PHISHING +20 pour ${c.id}`);
          }
        }

        if (specificTokens.includes("injection")) {
          const isInjectionCVE =
            titleLow.includes("injection") ||
            titleLow.includes("xss") ||
            titleLow.includes("sql");
          if (isInjectionCVE) {
            typeBonus += 20;
            console.log(`    üéØ BONUS INJECTION +20 pour ${c.id}`);
          }
        }

        // P√©nalit√© auth g√©n√©rique
        let authPenalty = 0;
        const isAuthCVE =
          titleLow.includes("authentication") ||
          titleLow.includes("login") ||
          titleLow.includes("credential") ||
          titleLow.includes("password");

        if (isAuthCVE) {
          const hasAuthTokens = specificTokens.some((t) =>
            [
              "authentication",
              "credential",
              "password",
              "session",
              "phishing",
              "oauth",
              "sso",
              "token",
            ].includes(t)
          );
          authPenalty = hasAuthTokens ? 5 : -15;
          console.log(
            `    ${hasAuthTokens ? "‚úÖ" : "‚ö†Ô∏è"} ${c.id} ${
              hasAuthTokens ? "bonus +5" : "p√©nalis√© -15"
            }: CVE auth ${hasAuthTokens ? "avec" : "sans"} contexte auth`
          );
        }

        // Score final
        const conf =
          tokenScore * 2 +
          criticalMatches * 5 +
          kevContribution +
          kevPenalty +
          recentBonus +
          agePenalty +
          typeBonus +
          authPenalty;

        matches.push({ conf, c, matchingTokens, year, age });
        console.log(
          `    ‚úÖ MATCH: ${c.id} (conf: ${conf}, tokens: ${tokenScore}, critical: ${criticalMatches}, bonus: ${typeBonus})`
        );
      }
    }
  }

  console.log(`  üìä Total matches: ${matches.length}`);

  // Tri d√©terministe avec tiebreaker
  matches.sort((a, b) => {
    if (b.conf !== a.conf) return b.conf - a.conf;
    if (b.year !== a.year) return b.year - a.year;
    return a.c.id.localeCompare(b.c.id); // Tiebreaker alphab√©tique
  });

  const bestMatch = matches[0];

  if (matches.length > 0) {
    console.log(`  üèÜ Top 3 matches:`);
    matches.slice(0, 3).forEach((m, i) => {
      console.log(`    ${i + 1}. ${m.c.id} (conf: ${m.conf})`);
    });
  }

  // ============================================================================
  // SEUIL CONFIANCE = 20 (strict pour √©viter CVE inadapt√©es)
  // ============================================================================

  if (bestMatch && bestMatch.conf >= 50) {
    console.log(
      `  üéØ ‚úÖ CVE ATTRIBU√â: ${bestMatch.c.id} (confiance: ${bestMatch.conf})`
    );

    const enrichedExtension = {
      ...data,
      extensionId: originalExtensionId,
      cve_id: bestMatch.c.id,
      cveid: bestMatch.c.id,
      mappedCVE: true,
      mappingConfidence: bestMatch.conf,
      mappingSource: bestMatch.c.src,
      mappingTitle: bestMatch.c.title,
      matchMethod: "token_correlation",
      specificTokens,
      matchingTokens: bestMatch.matchingTokens,
      isVirtual: false,
      // Champs KEV enrichis
      cve_description: bestMatch.c.description,
      cve_requiredAction: bestMatch.c.requiredAction,
      cve_notes: `${bestMatch.c.notes || ""}\n\nAI Detection - Indicators: ${
        indicators.length > 0 ? indicators.join(", ") : "None"
      }. Risk Score: ${riskScore}. Confidence: ${confidence}. Context: ${analysis.substring(
        0,
        200
      )}...`,
      cve_product: bestMatch.c.product,
      cve_vendor: bestMatch.c.vendor,
      _is_extension_data: true,
      original_data: {
        ...data.original_data,
        extensionId: originalExtensionId,
      },
    };
    out.push({ json: enrichedExtension, pairedItem: { item: ext.indexOf(e) } });
  } else {
    // ============================================================================
    // CVE VIRTUEL STABLE BAS√â SUR HASH URL
    // ============================================================================

    console.log(
      `  üõ°Ô∏è Aucun match pertinent (meilleur: ${
        bestMatch?.conf || 0
      }) - CVE virtuel STABLE`
    );

    // D√©terminer type de menace
    let threatType = "Unknown Threat";
    if (
      specificTokens.includes("malicious") ||
      specificTokens.includes("unwanted")
    ) {
      threatType = "Malware/Unwanted Software";
    } else if (specificTokens.includes("phishing")) {
      threatType = "Phishing/Social Engineering";
    } else if (specificTokens.includes("injection")) {
      threatType = "Web Injection Attack";
    } else {
      threatType = "Suspicious Content";
    }

    // Hash URL pour CVE stable
    const urlHash = hashURL(url);
    const virtualCVE = `CVE-2026-${urlHash}`;

    console.log(`  üîí URL hash: ${urlHash}`);
    console.log(`  üÜï CVE virtuel STABLE: ${virtualCVE} (type: ${threatType})`);

    const enrichedWithVirtual = {
      ...data,
      extensionId: originalExtensionId,
      cve_id: virtualCVE,
      cveid: virtualCVE,
      mappedCVE: false,
      mappingConfidence: 0,
      mappingSource: "virtual_stable",
      mappingTitle: `Virtual CVE: ${threatType} detected via browser navigation`,
      matchMethod: "no_match_virtual_stable",
      threatContext: {
        type: threatType,
        source: "browser_extension",
        product: "Web Browser",
        vector: "url_navigation",
        detectedTokens: specificTokens,
        targetUrl: url,
        urlHash: urlHash,
      },
      // ‚úÖ AJOUTER LES CHAMPS AI DE L'EXTENSION
      indicators: indicators,
      riskScore: riskScore,
      confidence: confidence,
      // Include AI detection data in cve_notes
      cve_notes: `AI Detection - Indicators: ${
        indicators.length > 0 ? indicators.join(", ") : "None"
      }. Risk Score: ${riskScore}. Confidence: ${confidence}. Context: ${analysis.substring(
        0,
        200
      )}...`,
      cve_description: `Virtual CVE created for ${threatType} threat detected via browser extension analysis. URL: ${url}`,
      cve_vulnerabilityName: threatType,
      cve_requiredAction:
        "Investigate and remediate based on AI recommendations",
      cve_product: "Web Application",
      cve_vendor: "Unknown Vendor",
      isVirtual: true,
      virtualYear: 2026,
      virtualReason: "No matching CVE in KEV/NIST database (threshold: 20)",
      _is_extension_data: true,
      original_data: {
        ...data.original_data,
        extensionId: originalExtensionId,
      },
    };

    out.push({
      json: enrichedWithVirtual,
      pairedItem: { item: ext.indexOf(e) },
    });
  }
}

// ============================================================================
// √âTAPE 6 : R√âSULTATS FINAUX
// ============================================================================

console.log(`\nüì§ === R√âSULTATS MAPPING CVE ===`);
console.log(`  Extensions en entr√©e: ${ext.length}`);
console.log(`  Extensions en sortie: ${out.length}`);
console.log(`  Items pool: ${pool.length}`);
console.log(`  Total: ${pool.length + out.length}`);

return [...pool, ...out];
