{
  "parameters": {
    "jsCode": "// === üîß GET EXTENSION QUEUE - BATCH MODE ===\nconsole.log('=== üîß BATCH QUEUE READER - D√âMARRAGE ===');\n\nconst API_URL = 'https://soc-cert-extension.vercel.app/api/extension-queue';\n\ntry {\n  // Faire la requ√™te GET vers la queue\n  const response = await fetch(API_URL, {\n    method: 'GET',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n  \n  if (!response.ok) {\n    console.log(`‚ùå Erreur HTTP: ${response.status}`);\n    return [{ error: 'Queue API error', status: response.status }];\n  }\n  \n  const queueData = await response.json();\n  console.log(`üì• Queue data re√ßue:`, JSON.stringify(queueData, null, 2));\n  \n  if (!queueData.success || !queueData.extensions) {\n    console.log('‚ùå Format de queue invalide');\n    return [{ error: 'Invalid queue format', data: queueData }];\n  }\n  \n  const extensions = queueData.extensions;\n  console.log(`üìä Total extensions dans la queue: ${extensions.length}`);\n  \n  if (extensions.length === 0) {\n    console.log('‚úÖ Queue vide - aucun traitement n√©cessaire');\n    return [{ message: 'Queue is empty', count: 0 }];\n  }\n  \n  // Filtrer les √©l√©ments non trait√©s\n  const unprocessedExtensions = extensions.filter(ext => !ext.processed);\n  console.log(`üîç Extensions non trait√©es: ${unprocessedExtensions.length}`);\n  \n  if (unprocessedExtensions.length === 0) {\n    console.log('‚úÖ Tous les √©l√©ments sont d√©j√† trait√©s');\n    return [{ message: 'All items processed', total: extensions.length }];\n  }\n  \n  // Prendre les 5 premiers pour √©viter la surcharge\n  const batchSize = Math.min(5, unprocessedExtensions.length);\n  const batchToProcess = unprocessedExtensions.slice(0, batchSize);\n  \n  console.log(`üéØ Traitement en batch de ${batchSize} √©l√©ments:`);\n  batchToProcess.forEach((ext, idx) => {\n    console.log(`  ${idx + 1}. extensionId: ${ext.extensionId}`);\n    console.log(`     url: ${ext.url}`);\n    console.log(`     threatType: ${ext.threatType}`);\n  });\n  \n  // Retourner le format attendu par le workflow\n  const result = {\n    success: true,\n    extensions: batchToProcess,\n    count: batchToProcess.length,\n    source: 'batch-queue-reader',\n    processedAt: new Date().toISOString()\n  };\n  \n  console.log('‚úÖ Batch pr√™t pour traitement');\n  return [result];\n  \n} catch (error) {\n  console.log('‚ùå Erreur lors de la lecture de la queue:', error.message);\n  return [{ \n    error: 'Queue read failed', \n    message: error.message,\n    timestamp: new Date().toISOString()\n  }];\n}"
  },
  "id": "batch-queue-reader",
  "name": "Batch Queue Reader",
  "type": "n8n-nodes-base.code",
  "typeVersion": 2,
  "position": [820, 300],
  "executeOnce": false,
  "retryOnFail": true,
  "maxTries": 3,
  "waitBetween": 1000,
  "alwaysOutputData": true,
  "onError": "continueRegularOutput",
  "continueOnFail": false,
  "notes": "Lit TOUS les √©l√©ments non trait√©s de la queue en batch (max 5 √† la fois)"
}
